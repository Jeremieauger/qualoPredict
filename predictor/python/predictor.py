# -*- coding: utf-8 -*-
### The inclusions ###
import os, re, datetime
from sklearn.naive_bayes import MultinomialNB
from sqlalchemy import create_engine
from connector import *
try:
   import cPickle as pickle
except:
   import pickle
### /inclusions ###

# Global variable
# predictions = []

### Functions ###
# Function to categorize the predicted make 
def rgb_to_hex(rgb):
    return '#%02x%02x%02x' % rgb

def hex1000(num):
    if num <= 200:
        r = num/200.0*255
        return rgb_to_hex((r,255,0))
    elif num <= 1000:
        g = (1-((num-200)/800.0))*255
        return rgb_to_hex((255,g,0))
    else:
        return rgb_to_hex((255,0,0))

# Function to verify if there is an entry in `nowRainAndTemp` at the specified date/time
def isEmpty(date):    
    emptyQueryFlag = -1
    query = "select `rain24h` from `nowRainAndTemp` where date='{}'".format(date)
    emptyEntry = connection.execute(query)
    for row in emptyEntry:
        emptyQueryFlag = row
    if emptyQueryFlag == -1: 
        return True
    else:
        return False

### /Functions ###


### Retrieving the most recent weather conditions from DB
# First, retrieving the most recent rain and temperature conditions
rainQuery = 'SELECT * FROM `nowRainAndTemp` ORDER  BY `date` DESC LIMIT  1'
rainAndTempRes =  connection.execute(rainQuery).fetchone()
(nowDatetime, rainNow, tempNow) = rainAndTempRes

### the model is based on IP3, which requires the last three 
# days of rain forecast [following: IP3 = J(mm) + J-1(mm)/2+ J-2(mm)/4]
# Getting yesterday's forecast - dayMinus1
todayInt = datetime.datetime.now().day
minus1Datetime = nowDatetime.replace('-'+str(todayInt)+'T', '-'+str(todayInt-1)+'T')
# Verification to prevent from integrating empty entry in case of value missing in DB
while isEmpty(minus1Datetime):
    # Retrieving the current hour value tried
    hour = int(re.search('T(\d\d):', minus1Datetime).group(1))
    if hour > 23:
        minus1Datetime = nowDatetime.replace('T'+str(hour)+':','T00:')
        continue
    # Adding one hour
    minus1Datetime = minus1Datetime.replace('T'+str(hour)+':','T'+str(int(hour)+1)+':')

rainMinus1Query = "SELECT `rain24h` FROM `nowRainAndTemp` WHERE date='{}'".format(minus1Datetime)
rainMinus1Res =  connection.execute(rainMinus1Query)
for row in rainMinus1Res:
    rainMinus1 = row[0]

# Getting two days ago's forecast
minus2Datetime = nowDatetime.replace('-'+str(todayInt)+'T', '-'+str(todayInt-2)+'T')
# Verification to prevent from integrating empty entry in case of value missing in DB
while isEmpty(minus2Datetime):
    # Retrieving the current hour value tried
    hour = int(re.search('T(\d\d):', minus2Datetime).group(1))
    if hour > 23:
        minus2Datetime = minus1Datetime.replace('T'+str(hour)+':','T00:')
        continue
    # Adding one hour
    minus2Datetime = minus2Datetime.replace('T'+str(hour)+':','T'+str(int(hour)+1)+':')

rainMinus2Query = "SELECT `rain24h` FROM `nowRainAndTemp` WHERE date='{}'".format(minus2Datetime)
rainMinus2Res =  connection.execute(rainMinus2Query)
for row in rainMinus2Res:
    rainMinus2 = row[0]

IP3 = rainNow + rainMinus1/2 + rainMinus2/4
### END of IP3 retrieving / calculation

# Retrieving the most recent Flow measurment
flowRequest = 'SELECT * FROM `nowFlow` ORDER  BY `date` DESC LIMIT  1'
flowRes  =  connection.execute(flowRequest).fetchone()
(flowMostRecent, flowNow) = flowRes

# Retrieving the most recent Level measurment
levelRequest = 'SELECT * FROM `nowLevel` ORDER  BY `date` DESC LIMIT  1'
levelRes  =  connection.execute(levelRequest).fetchone()
(levelMostRecent, levelNow) = levelRes

# Setting current conditions 'IP3','MeanTemp','Flow','Level'
currentCond = [IP3, tempNow, flowNow, levelNow]

# Importing the models generated by "model_pickler.py"
path = os.environ.get('OPENSHIFT_REPO_DIR')
models = pickle.load( open( "{}python/models.p".format(path), "rb" ) )


dropQuery = "DROP TABLE IF EXISTS `nowPredictions`;"
connection.execute(dropQuery)
createQuery = " CREATE TABLE `nowPredictions` ( `Station` varchar(15) NOT NULL, `Latitude` float(18,16), `Longitude` float(18,16), `UFC` int(10), `Color` varchar(10), `date` date, `hour` int(2), `minute` INT(2) ZEROFILL, PRIMARY KEY (`Station`), KEY `Station` (`Station`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8;"
connection.execute(createQuery)
createQuery = "CREATE TABLE IF NOT EXISTS `predictions` ( `Station` varchar(15) NOT NULL, `date` date NOT NULL, `Average` float(11,1) DEFAULT NULL, `6h` int(10) DEFAULT NULL, `7h` int(10) DEFAULT NULL, `8h` int(10) DEFAULT NULL, `9h` int(10) DEFAULT NULL, `10h` int(10) DEFAULT NULL, `11h` int(10) DEFAULT NULL, `12h` int(10) DEFAULT NULL, `13h` int(10) DEFAULT NULL, `14h` int(10) DEFAULT NULL, `15h` int(10) DEFAULT NULL, `16h` int(10) DEFAULT NULL, `17h` int(10) DEFAULT NULL, `18h` int(10) DEFAULT NULL, PRIMARY KEY (`Station`,`date`), KEY `Station` (`Station`), KEY `date` (`date`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8;"
connection.execute(createQuery)

now = datetime.datetime.now()
# Making the predictions and updating nowPredictions
for name, model in models.iteritems():
    predicted = model.predict([currentCond])
    (Station, UFC, Color) = (name, predicted[0], hex1000(predicted[0]))
    date = "{}-{}-{}".format(now.year, now.month, now.day)
    updateQuery = "INSERT INTO `nowPredictions` (Station, UFC, Color, date, hour, minute) VALUES ('{0}','{1}','{2}','{3}','{4}','{5}')".format(Station, UFC, Color, date, now.hour, now.minute)
    connection.execute(updateQuery)
    if now.hour < 6 or now.hour > 18:
        continue
    storeQuery = "INSERT INTO `predictions` (Station, date, {0}h) VALUES ('{1}','{2}','{3}') ON DUPLICATE KEY UPDATE {0}h='{3}';".format(now.hour, name, date, UFC)
    connection.execute(storeQuery)


